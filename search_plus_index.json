{"./":{"url":"./","title":"MongoDB-开篇简介","keywords":"","body":"mongodb-guide         以下内容是学习MongoDB的个人笔记和文档整理。 By mongodb-guide，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2022-06-17 02:07:42 "},"book/mongodb-guide-chapter1.html":{"url":"book/mongodb-guide-chapter1.html","title":"MongoDB-第一章-简介","keywords":"","body":"简介         MongoDB是一种文档类型的数据库，具备了扩展性强的特性，支持诸如：辅助索引、范围查询以及排序等功能。         在主要功能基础上，还支持一些高阶特性，比如：内置的MapReduce支持和地理空间索引的支持。 丰富的数据模型         MongoDB是面向文档的数据库，放弃关系模型的主要原因就是为了获得更加方便的扩展性。在关系数据库中的 行 在MongoDB中是灵活的 文档，一行记录就是一个文档，而文档是没有模式的，文档中的键不会实现定义也不会固定不变。 容易扩展         T级别的数据在IoT大发展时代变得很寻常了，开发者需要从一开始就要考虑数据量级，而MongoDB在最初的设计中就考虑了扩展的问题，能够在多个服务器上分割数据，也就是从一开始就考虑支持数据的分片。 丰富的功能 功能 描述 索引 MongoDB支持通用辅助索引，能够快速的增加一些索引 Javascript运作 MongoDB能够在服务端进行Javascript运行 聚合 MongoDB支持MapReduce以及多种聚合工具进行查询 固定集合 限制集合上限（表的行上限） 文件存储 MongoDB底层的GridFS可以用来完成一些大文件的分布式存储 性能         性能是MongoDB主打的目标，默认的存储引擎使用了内存映射文件，而动态查询优化器会优化查询过程，同时MongoDB将服务端的一些处理逻辑放在客户端，使得MongoDB具备了非常好的性能。 容易运维         MongoDB尽可能的简化运维工作，只需要建立起主从的拓扑结构，当分布式环境中出现了故障，系统会自动完成主备切换，当新增节点加入是，会自动集成和配置新加入的节点。 By mongodb-guide，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2022-06-17 02:07:42 "},"book/mongodb-guide-chapter2.html":{"url":"book/mongodb-guide-chapter2.html","title":"MongoDB-第二章-入门","keywords":"","body":"入门         文档是MongoDB的基本单元，类似于关系数据库中的行，而集合是文档的聚合，因此集合类似关系数据库中的表，在一个集合中可以装在不同模式的文档。每个文档都会有一个_id的主键。         一个MongoDB实例可以建立多个数据库，每个数据库都可以创建多个集合，而MongoDB通过基于JavaScript的shell来管理数据库。 文档         文档是MongoDB的核心概念，在MongoDB中一个文档就是一个键值对的集合，例如：{\"foo\", 3, \"bar\":\"4\"}。文档的键是字符串，且不能有重复的键出现。 集合         一组文档会形成集合，一般来说集合是无模式的，你可以把不同类型的文档都放在一个集合中，但是这样对于开发者来说，就是一个噩梦。将相同类型的文档放置在一个集合中，会使数据更加集中，同时也更利于查询，因为索引是根据集合来建立的，这样相同的文档在一个集合中，索引将会更有效。         数据库的命名一般是小写，有一些数据库是默认保留的。 在安装了Docker的机器上，运行sudo docker run --name mongo-test -d -p 27017:27017 mongo:3.6.9，会拉起一个MongoDB（版本是3.6.9），同时端口是27017。         保留的数据库是： admin，local和config。 运行MongoDB Shell         MongoDB自带了一个Javascript Shell，可以使用命令行的方式和MongoDB进行交互，可以使用它进行管理操作，检查状态等。 可以使用sudo docker exec -it mongo-test mongo，其中mongo-test是MongoDB对应的docker实例名称。 weipeng2k@weipeng2k-workstation:~$ sudo docker exec -it mongo-test mongo MongoDB shell version v3.6.9 connecting to: mongodb://127.0.0.1:27017 Implicit session: session { \"id\" : UUID(\"af9c08c0-3bec-4677-b0df-86bb37b0a7c7\") } MongoDB server version: 3.6.9 >         可以在mongodb shell中执行javascript程序，例如： > x=200 200 > print(x) 200         可以使用use $db命令来进行数据库切换，比如：切换到test数据库。 > use test switched to db test > db test 可以使用show dbs或者在一个数据库中使用show collections来查看当前MongoDB实例部署的数据库，以及当前数据库中的集合。这些命令和mysql很相似。 创建数据         可以在MongoDB Shell中进行数据的定义，然后通过执行db.$collection_name.insert($variable)来进行数据的插入，通过执行这个命令，以将一个文档插入到集合中。 > author = {\"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-1111111\", \"age\" : 21} { \"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-1111111\", \"age\" : 21 } > db.author_test_collection.insert(author) WriteResult({ \"nInserted\" : 1 }) > db.author_test_collection.find({\"name\":\"Author-1111111\"}) { \"_id\" : ObjectId(\"5cfa7edbb263c5548e111e25\"), \"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-1111111\", \"age\" : 21 } > 获取数据         创建数据后，可以使用db.$collection_name.find($query_expression)来获取数据。除了使用对应的表达式进行查询（在后续的内容中进行详细介绍），还可以使用比较简单的方式进行获取，比如：使用db.$collection_name.findOne()，该查询会返回一个集合中的文档。 > db test > db.author_test_collection.findOne() { \"_id\" : ObjectId(\"5c6533707ed82520f5504bcb\"), \"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-0\", \"age\" : 26 } 可以使用db命令来查询当前会话是使用的哪个数据库。 更新数据         通过使用一个给定的查询方式和目标文档，可以将集合中的文档进行更新。 > db.author_test_collection.findOne() { \"_id\" : ObjectId(\"5c6533707ed82520f5504bcb\"), \"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-0\", \"age\" : 26 } > updateAuthor = { \"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-0\", \"age\" : 27 } { \"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-0\", \"age\" : 27 } > db.author_test_collection.update({\"name\":\"Author-0\"}, updateAuthor) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.author_test_collection.findOne() { \"_id\" : ObjectId(\"5c6533707ed82520f5504bcb\"), \"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-0\", \"age\" : 27 }         通过上面的命令可以看出，对于 Author-0 这个名称的文档，通过update操作，将其 age 属性进行了更新。当然，除了更新文档中已经存在的内容，也可以增加一些属性。 > updateAuthor = { \"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-0\", \"age\" : 27, \"sex\":\"male\" } { \"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-0\", \"age\" : 27, \"sex\" : \"male\" } > db.author_test_collection.update({\"name\":\"Author-0\"}, updateAuthor) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.author_test_collection.findOne() { \"_id\" : ObjectId(\"5c6533707ed82520f5504bcb\"), \"_class\" : \"com.murdock.books.mongodbguide.domain.Author\", \"name\" : \"Author-0\", \"age\" : 27, \"sex\" : \"male\" } 删除数据         如果想删除文档，自然就可以使用db.$collection_name.remove($query_expression)。对于符合查询条件的文档，将会从集合中删除。 > db.author_test_collection.remove({\"sex\":\"male\"}) WriteResult({ \"nRemoved\" : 1 }) > db.author_test_collection.find({\"name\":\"Author-0\"}) 可以看到只要符合文档中有属性 sex 为 male的，都会被删除。 数据类型         MongoDB的文档类似于JSON，虽然JSON的数据表现能力很强，但是还是无法满足一些特定要求，比如：时间类型。所以MongoDB针对这种场景做了一些扩展。 类型 描述 null 空值 布尔 true或者false 整数 分为32位和64位 浮点数 64位双精度浮点数 字符串 字符数组，类似：\"string\" 对象ID 在一个集合中唯一定位一个文档，ObjectId() 日期 Date 数组 值的集合或者列表，类似：[\"A\", \"B\", \"C\"] 内嵌文档 文档是一级KV，如果在V中包含了KV，那么就是内嵌文档 以上是主要的数据类型。 时间类型         日期类型存储的是从标准纪元开始的时间，如果换算到中国时区，需要+8。 > v = {\"x\": new Date()} { \"x\" : ISODate(\"2019-06-08T12:29:21.063Z\") } 内嵌文档         相当于在MongoDB中的一个文档被嵌入到了另一个文档中，这种组合形式就不会让文档拘泥于扁平形式。而MongoDB支持在内嵌文档上进行索引建立，虽然数据可能有重复，但是形式表达会更加自然。 对象ID         在MongoDB的任何文档中，都会有一个属性_id，它所存储的是这个集合中的唯一标识。         默认情况下MongoDB的客户端会自动生成一个对象ID，它通过使用当前机器名、进程等标识信息生成了一个12byte的对象ID。类似Mysql的id autoincreament一样，能够生成不同的数据主键，但是MongoDB把这个工作放在了客户端，这样就减轻了服务端的压力。 By mongodb-guide，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2022-06-17 02:07:42 "},"book/mongodb-guide-chapter3.html":{"url":"book/mongodb-guide-chapter3.html","title":"MongoDB-第三章-创建、更新和删除文档","keywords":"","body":"创建、更新和删除文档         使用一款数据库，最主要的就是对其（关系或集合）进行增删改查，接下来就介绍如何在MongoDB中进行数据的新增、删除和修改，以及这些操作在MongoDB中的特点。 插入文档         通过使用insert命令可以向一个集合中插入新的文档，对于新增的文档，MongoDB客户端会生成一个_id。 > item = {\"name\":\"murdock\", \"age\":18} > db.foo.insert(item) > show collections author_test_collection blog_test_collection foo mongo_task_instance_collection mongo_test_collecion mongo_test_collection         首先定义了一个对象item，随后通过insert命令将其插入到集合foo中。 如果集合不存在，MongoDB会新建立一个集合。 通过show collections可以查看当前数据库中的所有集合。         在Java中，我们可以使用 spring-data 来进行文档的插入。 @Test public void insert() { DBObject dbObject = new BasicDBObject(); dbObject.put(\"name\", \"test\"); dbObject.put(\"age\", 18); mongoTemplate.getCollection(\"foo\").insert(dbObject); }         通过构建DBObject，向其设置值，并将其插入到文档中。DBObject类似Map。和关系数据库类似，对于插入，MongoDB也提供了批量新增的方式，也可以使用insert方法进行。 > items = [{\"name\":\"murdock\", \"age\":19}, {\"name\":\"john\", \"age\":20}] [ { \"name\" : \"murdock\", \"age\" : 19 }, { \"name\" : \"john\", \"age\" : 20 } ] > db.foo.insert(items) BulkWriteResult({ \"writeErrors\" : [ ], \"writeConcernErrors\" : [ ], \"nInserted\" : 2, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) > db.foo.find() { \"_id\" : ObjectId(\"5cfcf12a6c1c3f471c95190c\"), \"name\" : \"murdock\", \"age\" : 18 } { \"_id\" : ObjectId(\"5cfcfba16c1c3f471c95190d\"), \"name\" : \"murdock\", \"age\" : 19 } { \"_id\" : ObjectId(\"5cfcfba16c1c3f471c95190e\"), \"name\" : \"john\", \"age\" : 20 }         可以看到对于insert方法，传入了一个数组，MongoDB可以按照数组内容进行插入，好处在于一次通信交互，可以新增多个文档。 和MongoDB之间的消息长度不能超过16MB，所以对于批量新增，也需要做好单次容量的估算。 对于Java端的操作可以参考：com.murdock.books.mongodbguide.chapter3.InsertTest 插入的原理         在InsertTest中可以使用如下代码对foo集合中进行插入。 @Test public void insert() { DBObject dbObject = new BasicDBObject(); dbObject.put(\"name\", \"test\"); dbObject.put(\"age\", 18); mongoTemplate.getCollection(\"foo\").insert(dbObject); }         这里使用的是MongoDB的Java驱动，当进行insert时，如果没有对应的集合时，MongoDB就会创建对应的集合。前面提到_id字段，这个是每个文档都会具备的，而例子中进行插入的数据，没有设置_id字段。MongoDB会检查插入的文档，当文档中没有包含_id，MongoDB客户端会生成一个。 public WriteResult insert(final List documents, final InsertOptions insertOptions) { WriteConcern writeConcern = insertOptions.getWriteConcern() != null ? insertOptions.getWriteConcern() : getWriteConcern(); Encoder encoder = toEncoder(insertOptions.getDbEncoder()); List insertRequestList = new ArrayList(documents.size()); for (DBObject cur : documents) { if (cur.get(ID_FIELD_NAME) == null) { cur.put(ID_FIELD_NAME, new ObjectId()); } insertRequestList.add(new InsertRequest(new BsonDocumentWrapper(cur, encoder))); } return insert(insertRequestList, writeConcern, insertOptions.isContinueOnError(), insertOptions.getBypassDocumentValidation()); } 见com.mongodb.DBCollection#insert(java.util.List, com.mongodb.InsertOptions)         可以看到，文档中没有_id属性，MongoDB客户端就会生成一个。可以看一下ObjectId的构造函数，以及相关的处理逻辑。 buffer.put(int3(timestamp)); buffer.put(int2(timestamp)); buffer.put(int1(timestamp)); buffer.put(int0(timestamp)); buffer.put(int2(machineIdentifier)); buffer.put(int1(machineIdentifier)); buffer.put(int0(machineIdentifier)); buffer.put(short1(processIdentifier)); buffer.put(short0(processIdentifier)); buffer.put(int2(counter)); buffer.put(int1(counter)); buffer.put(int0(counter));         对于默认的ObjectId的生成，一个12bytes的主键，前4个byte是时间戳，后三个是机器标示（一般是网卡相关的信息），接下来是进程标示，最后是随机生成的3个byte。 由于timestamp的单位是秒，那么在一个进程中进行区分的就是counter部分的3个byte，而3个byte的数据内容是：16777216，一千六百多万。可以说在一秒内，对于一个进程内容，如果不超过一千六百万的TPS，就不会有问题。事实上，现实中不会有这么高的TPS，因为单进程这么高的TPS已经让网卡都被打满。 删除文档         通过使用remove命令，可以完成对集合中文档的删除动作。 > db.foo.find() { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b52\"), \"name\" : \"test\", \"age\" : 18 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b53\"), \"name\" : \"test\", \"age\" : 19 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b54\"), \"name\" : \"test\", \"age\" : 20 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b55\"), \"name\" : \"test\", \"age\" : 21 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b56\"), \"name\" : \"test\", \"age\" : 22 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b57\"), \"name\" : \"test\", \"age\" : 23 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b58\"), \"name\" : \"test\", \"age\" : 24 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b59\"), \"name\" : \"test\", \"age\" : 25 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b5a\"), \"name\" : \"test\", \"age\" : 26 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b5b\"), \"name\" : \"test\", \"age\" : 27 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b5c\"), \"name\" : \"test\", \"age\" : 28 } { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b5d\"), \"name\" : \"test\", \"age\" : 29 } > db.foo.remove({\"age\" : {\"$gte\":19}}) WriteResult({ \"nRemoved\" : 11 }) > db.foo.find() { \"_id\" : ObjectId(\"5d0638e1afe8102aeab43b52\"), \"name\" : \"test\", \"age\" : 18 } 对于Java端的操作可以参考：com.murdock.books.mongodbguide.chapter3.RemoveTest         使用MongoDB的Java客户端，进行删除文档的关键逻辑如下： DBObject ageGte = new BasicDBObject(); ageGte.put(\"$gte\", 19); DBObject removeQuery = new BasicDBObject(); removeQuery.put(\"age\", ageGte); WriteResult writeResult = mongoTemplate.getCollection(\"foo\").remove(removeQuery); System.out.println(\"remove:\" + writeResult.getN()); Assert.assertTrue(writeResult.getN() >= 11); System.out.println(\"count:\" + mongoTemplate.getCollection(\"foo\").count());         可以看到通过DBObject可以构造出remove方法需要的参数，其中$gte是一个操作，代表大于等于一个值。 更新文档         通过使用update命令，可以完成对集合中文档的修改动作。 > db.foo.find() { \"_id\" : ObjectId(\"5d0dfb1becfa8c49ce3fb2b5\"), \"name\" : \"test\", \"age\" : 18 } > var f = {\"name\" : \"test\", \"age\" : 18} > f { \"name\" : \"test\", \"age\" : 18 } > f.level = \"high\" high > f { \"name\" : \"test\", \"age\" : 18, \"level\" : \"high\" } > db.foo.update({\"name\":\"test\"}, f) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.find() { \"_id\" : ObjectId(\"5d0dfb1becfa8c49ce3fb2b5\"), \"name\" : \"test\", \"age\" : 18, \"level\" : \"high\" } 对于Java端的操作可以参考：com.murdock.books.mongodbguide.chapter3.UpdateTest         使用MongoDB的Java客户端，进行更新文档的关键逻辑如下： DBObject dbObject = new BasicDBObject(); dbObject.put(\"name\", \"test\"); dbObject.put(\"level\", \"high\"); dbObject.put(\"age\", 20); DBObject query = new BasicDBObject(); query.put(\"name\", \"test\"); WriteResult result = mongoTemplate.getCollection(\"foo\").update(query, dbObject); System.out.println(result.getN() >= 1);         以上的修改方式，属于覆盖式修改，但是我们对于文档的修改，往往是集中在某个属性。针对部分属性的修改，可以使用以下方式。 $SET         由于默认的Update是全部覆盖，当需要为指定的文档添加一个字段，就需要使用set进行操作。 > db.foo.findOne() { \"_id\" : ObjectId(\"5d6bb09124b8e520faedc0aa\"), \"name\" : \"test\", \"age\" : 18, \"sex\" : \"male\" } > db.foo.update({\"name\":\"test\"}, {\"$set\":{\"sex\":\"female\"}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.findOne() { \"_id\" : ObjectId(\"5d6bb09124b8e520faedc0aa\"), \"name\" : \"test\", \"age\" : 18, \"sex\" : \"female\" }         可以看到使用$set，将sex属性从male改为了female。 对于Java端的操作可以参考：com.murdock.books.mongodbguide.chapter3.UpdateTest         使用MongoDB的Java客户端，进行更新文档的关键逻辑如下： DBObject update = new BasicDBObject(); DBObject prop = new BasicDBObject(); prop.put(\"sex\", \"male\"); update.put(\"$set\", prop); mongoTemplate.getCollection(\"foo\").update(query, update);         使用$set进行更新，当文档没有对应的key时会添加，有的话，则修改。 $INC         针对文档中的数字类型，可以使用增加inc进行操作，将一个文档中的数字属性进行增加或者减少（负数）。 > db.foo.findOne() { \"_id\" : ObjectId(\"5d0e0dceecfa8c49ce3fb2b7\"), \"name\" : \"test\", \"age\" : 18, \"level\" : \"high\" } > db.foo.update({\"name\":\"test\"} , {\"$inc\":{\"age\":1}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.update({\"name\":\"test\"} , {\"$inc\":{\"age\":1}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.findOne() { \"_id\" : ObjectId(\"5d0e0dceecfa8c49ce3fb2b7\"), \"name\" : \"test\", \"age\" : 20, \"level\" : \"high\" }         可以看到使用$inc，将age从18变为20。 对于Java端的操作可以参考：com.murdock.books.mongodbguide.chapter3.UpdateTest         使用MongoDB的Java客户端，进行更新文档的关键逻辑如下： DBObject update = new BasicDBObject(); DBObject prop = new BasicDBObject(); prop.put(\"age\", 1); update.put(\"$inc\", prop); mongoTemplate.getCollection(\"foo\").update(query, update);         使用$inc进行更新，能够保证当前文档对应的属性更新是原子化的。 更新文档，数组属性 $PUSH         MongoDB支持的数据类型除了：整型、浮点型、日期以及字符串这种单值类型的之外，还有数组类型。如果对于一个文档中的数组属性进行操作时，可以使用push进行操作。 该操作只能针对数组属性 > db.foo.update({\"name\":\"test\"}, {\"$push\":{\"hobbies\":\"reading\"}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.findOne() { \"_id\" : ObjectId(\"5d6bb09124b8e520faedc0aa\"), \"name\" : \"test\", \"age\" : 18, \"sex\" : \"female\", \"hobbies\" : [ \"reading\" ] } > db.foo.update({\"name\":\"test\"}, {\"$push\":{\"hobbies\":\"tvgaming\"}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.findOne() { \"_id\" : ObjectId(\"5d6bb09124b8e520faedc0aa\"), \"name\" : \"test\", \"age\" : 18, \"sex\" : \"female\", \"hobbies\" : [ \"reading\", \"tvgaming\" ] }         可以看到通过使用push将一个元素添加到对应的数组的尾部。 对于Java端的操作可以参考：com.murdock.books.mongodbguide.chapter3.ArrayUpdateTest         使用MongoDB的Java客户端，进行更新文档的关键逻辑如下： DBObject update = new BasicDBObject(); DBObject prop = new BasicDBObject(); prop.put(\"hobbies\", \"reading\"); update.put(\"$push\", prop); mongoTemplate.getCollection(\"foo\").update(query, update);         使用$push进行数组元素的更新，当文档没有对应的数组key时会添加，并将元素添加到数组的尾部。 $ADDTOSET         使用push命令可以向一个文档中的数组属性里添加内容，但是如果该内容已经在数组中出现，而本次添加是当元素在数组中不存在时才生效时，就需要使用addToSet。 > db.foo.update({\"name\":\"test\"}, {\"$addToSet\":{\"hobbies\":\"football\"}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.findOne() { \"_id\" : ObjectId(\"5d6bc02d24b8e52357933ed0\"), \"name\" : \"test\", \"age\" : 18, \"hobbies\" : [ \"reading\", \"tvgaming\", \"football\" ] } > db.foo.update({\"name\":\"test\"}, {\"$addToSet\":{\"hobbies\":\"football\"}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 0 }) > db.foo.findOne() { \"_id\" : ObjectId(\"5d6bc02d24b8e52357933ed0\"), \"name\" : \"test\", \"age\" : 18, \"hobbies\" : [ \"reading\", \"tvgaming\", \"football\" ] }         可以看到通过使用addToSet将一个元素以集合Set的视角添加入一个数组，当数组中存在该元素的时候，不会添加。 对于Java端的操作可以参考：com.murdock.books.mongodbguide.chapter3.ArrayUpdateTest         使用MongoDB的Java客户端，进行更新文档的关键逻辑如下： DBObject update = new BasicDBObject(); DBObject prop = new BasicDBObject(); prop.put(\"hobbies\", \"reading\"); update.put(\"$addToSet\", prop); mongoTemplate.getCollection(\"foo\").update(query, update); $POP         使用pop命令可以将一个文档中的数组属性里移出元素，就好比栈一样，调用pop就会将栈顶元素移出。可以使用{\"$pop\":{key:-1}}从尾部移出元素。 > db.foo.find() { \"_id\" : ObjectId(\"5d6bc02d24b8e52357933ed0\"), \"name\" : \"test\", \"age\" : 18, \"hobbies\" : [ \"reading\", \"tvgaming\", \"football\", \"tvgaming\", \"basketball\" ] } > db.foo.update({\"name\":\"test\"}, {\"$pop\":{\"hobbies\":-1}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.find() { \"_id\" : ObjectId(\"5d6bc02d24b8e52357933ed0\"), \"name\" : \"test\", \"age\" : 18, \"hobbies\" : [ \"tvgaming\", \"football\", \"tvgaming\", \"basketball\" ] } > db.foo.update({\"name\":\"test\"}, {\"$pop\":{\"hobbies\":1}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.find() { \"_id\" : ObjectId(\"5d6bc02d24b8e52357933ed0\"), \"name\" : \"test\", \"age\" : 18, \"hobbies\" : [ \"tvgaming\", \"football\", \"tvgaming\" ] } > db.foo.update({\"name\":\"test\"}, {\"$pop\":{\"hobbies\":-1}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.find() { \"_id\" : ObjectId(\"5d6bc02d24b8e52357933ed0\"), \"name\" : \"test\", \"age\" : 18, \"hobbies\" : [ \"football\", \"tvgaming\" ] }         可以看到通过使用pop将一个数组中的一个元素移除。 对于Java端的操作可以参考：com.murdock.books.mongodbguide.chapter3.ArrayUpdateTest         使用MongoDB的Java客户端，进行更新文档的关键逻辑如下： DBObject pop = new BasicDBObject(); DBObject popKey = new BasicDBObject(); popKey.put(\"hobbies\", -1); pop.put(\"$pop\", popKey); mongoTemplate.getCollection(\"foo\").update(query, pop); 也可以通过pull命名，指定的移出某个数组中的元素。 更新文档，高阶特性 $UPSERT         在进行数据插入时，经常会遇到一个问题，就是如果主键存在则获取已经存在的数据，否则插入，每当这时候我们需要谨慎的处理，需要增加主键的约束，处理回滚的事务。MongoDB提供了upsert命令用来完成这个工作，且该命令是原子性的。 > db.foo.update({\"name\": \"test\"}, {\"$inc\": {\"age\": 1}}, true) WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 1, \"nModified\" : 0, \"_id\" : ObjectId(\"5d9a89e540eabd2b62ced5e9\") }) > db.foo.find() { \"_id\" : ObjectId(\"5d9a89e540eabd2b62ced5e9\"), \"name\" : \"test\", \"age\" : 1 } > db.foo.update({\"name\": \"test\"}, {\"$inc\": {\"age\": 1}}, true) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.foo.find() { \"_id\" : ObjectId(\"5d9a89e540eabd2b62ced5e9\"), \"name\" : \"test\", \"age\" : 2 }         可以看到通过在update的第三个参数传入true，可以将一个修改的命令变成一个upsert命令。 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter3.AdvancedUpdateTest         使用MongoDB的Java客户端，进行更新文档的关键逻辑如下： DBObject query = new BasicDBObject(); query.put(\"name\", \"test\"); DBObject update = new BasicDBObject(); DBObject age = new BasicDBObject(); age.put(\"age\", 1); update.put(\"$inc\", age); WriteResult update1 = collection.update(query, update, true, false);         如果多次通过update进行更新，可以看到第一次更新是进行数据的插入，而后续的更新都是针对该文档的更新。 FindAndModify         当我们遇到并发更新一行数据时，在使用关系数据库时，经常使用乐观锁进行控制。比如：定义一个字段version，当更新时，需要传入查询出的最新version，也只有version和对应行记录中的version一致时，方可更新。这样是可以完成对于一行的并发更新，问题就是需要将这个version定义在每个需要并发更新的数据结构中。         这种单行（文档）的并发更新，是一种常见的更新场景，MongoDB对于这种更新场景提供了更加简单的使用方式。 > db.runCommand({ ... \"findAndModify\":\"foo\", ... \"query\":{\"name\": \"test\"}, ... \"update\":{\"$set\":{\"age\":30}} ... }) { \"lastErrorObject\" : { \"n\" : 1, \"updatedExisting\" : true }, \"value\" : { \"_id\" : ObjectId(\"5d9aa2d640eabd2b62ced639\"), \"name\" : \"test\", \"age\" : 5 }, \"ok\" : 1 } > db.foo.findOne() { \"_id\" : ObjectId(\"5d9aa2d640eabd2b62ced639\"), \"name\" : \"test\", \"age\" : 30 }         findAndModify命令需要输入集合等相关的更新信息，对应的键和类型如下： 键 类型 描述 findAndModify 字符串 对应的集合名 query 文档 查询的文档，用来检索 sort 文档 排序的文档，用来对检索的结果进行排序 update 文档 修改的文档，用来修改 remove 布尔 是否删除文档 new 布尔 是否返回更新后的文档         findAndModify只能对已经存在的文档进行更新，而且一次只能更新一行。相比较而言findAndModify的耗时相当于一次查询、一次更新和执行一次getLastError所需的时间。 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter3.AdvancedUpdateTest         使用MongoDB的Java客户端，进行更新文档的关键逻辑如下： DBObject query = new BasicDBObject(); query.put(\"name\", \"test\"); DBObject update = new BasicDBObject(); DBObject age = new BasicDBObject(); age.put(\"age\", 20); update.put(\"$set\", age); DBObject andModify = collection.findAndModify(query, null, null, false, update, true, false); By mongodb-guide，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2022-06-17 02:07:42 "},"book/mongodb-guide-chapter4.html":{"url":"book/mongodb-guide-chapter4.html","title":"MongoDB-第四章-查询","keywords":"","body":"查询         对MongoDB进行新增、修改和删除后，最主要的功能就是对数据（集合）进行查询，MongoDB支持丰富的查询功能。 查询简介         使用find命令可以查询集合中的文档，并返回符合要求的文档子集。查询命令的第一个参数是查询的模式，第二个参数是指定返回的键。查询的模式有些类似JPA中的查询模式，只需要表述需要的模式就行，例如：如果要查询属性name为test的文档，模式就是：{\"name\": \"test\"}。返回的键可以通过声明指定的键即可，例如：如果要返回name，声明就是：{\"name\": 1}。         如果需要查询age为20的name，查询命令参数就是：{\"age\": 20}, {\"name\": 1}。 > db.foo.find({\"age\": 20}, {\"name\": 1}) { \"_id\" : ObjectId(\"5d9ab1e940eabd2b62ced66f\"), \"name\" : \"test\" } > db.foo.find({\"age\": 20}, {\"name\": 1, \"age\": 1}) { \"_id\" : ObjectId(\"5d9ab1e940eabd2b62ced66f\"), \"name\" : \"test\", \"age\" : 20 } > db.foo.find({\"age\": 20}, {\"name\": 1, \"_id\": 0}) { \"name\" : \"test\" } 默认会返回属性_id，如果不需要可以声明{\"_id\": 0}         find是和MongoDB交互的基础命令，可以通过它来查询集合中的文档（数据）。 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.FindTest         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBObject query = new BasicDBObject(); query.put(\"age\", 20); DBObject project = new BasicDBObject(); project.put(\"name\", 1); project.put(\"_id\", 0); DBCursor dbObjects = collection.find(query, project); dbObjects.forEach(System.out::println); dbObjects = collection.find(query); dbObjects.forEach(System.out::println);         Collection.find()方法的文档描述是：Select documents in collection and get a cursor to the selected documents.，可以看到调用find方法，返回的是指向符合查询条件要求的文档游标。只要我们获取了游标，我们就可以遍历它，访问符合我们要求的文档了。 这里和JDBC有些区别，传统的JDBC通过Collection和Statement访问RDBMS后，得到的是数据集RowSet 根据条件查询         通过使用find命令，可以查询集合中符合要求的文档，但是我们对于数据库的使用不是只限定在这种简单的操作，还有一些比较通用的查询要求，比如：范围查询等。 条件查询         在SQL查询中，可以使用>或者来进行范围的控制，也就是比较操作符。在MongoDB中，由于查询的语句都是JSON，所以需要用转移字符来替换掉我们常用的比较操作符。         对应关系如下表： 类型 描述 $lt less than，也就是 $lte less than or equal，也就是 $gt greater than，也就是 > $gte greater than or equal，也就是 >= $ne not equal, 也就是 <>         根据age进行范围查询，先查询age小于等于21的。 > db.foo.find(); { \"_id\" : ObjectId(\"5d9ab1e940eabd2b62ced66f\"), \"name\" : \"test\", \"age\" : 20 } { \"_id\" : ObjectId(\"5dda6f29f75cb1b4beb2d95f\"), \"name\" : \"x\", \"age\" : 21 } > db.foo.find({\"age\": {\"$lte\" : 20}}) { \"_id\" : ObjectId(\"5d9ab1e940eabd2b62ced66f\"), \"name\" : \"test\", \"age\" : 20 } > db.foo.find({\"age\": {\"$gt\" : 20}}) { \"_id\" : ObjectId(\"5dda6f29f75cb1b4beb2d95f\"), \"name\" : \"x\", \"age\" : 21 }         可以看到查询语句中，先给出了限定的文档字段age，随后跟着对字段的限定内容。、 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.ConditionFindTest         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBObject query = new BasicDBObject(); DBObject condition = new BasicDBObject(); condition.put(\"$gt\", 20); query.put(\"age\", condition); DBCursor dbObjects = collection.find(query);         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： $IN         在关系数据库中，可以使用in查询来进行单key的多值查询，比如： select * from user where age in (18, 19, 20);         上述SQL可以查询age为18、19或者20的所有user，而这种查询方式，MongoDB也有提供，方式和SQL很类似。 > db.foo.find() { \"_id\" : ObjectId(\"5d9ab1e940eabd2b62ced66f\"), \"name\" : \"test\", \"age\" : 20 } { \"_id\" : ObjectId(\"5dda6f29f75cb1b4beb2d95f\"), \"name\" : \"x\", \"age\" : 21 } > db.foo.find({\"age\": {\"$in\": [20,21]}}) { \"_id\" : ObjectId(\"5d9ab1e940eabd2b62ced66f\"), \"name\" : \"test\", \"age\" : 20 } { \"_id\" : ObjectId(\"5dda6f29f75cb1b4beb2d95f\"), \"name\" : \"x\", \"age\" : 21 }         可以看到查询语句中，对于文档属性name进行了限定，限定描述是$in，同时指定值是[20, 21]。 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.InFindTest         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBObject query = new BasicDBObject(); DBObject condition = new BasicDBObject(); condition.put(\"$in\", new int[]{20, 21}); query.put(\"age\", condition); DBCursor dbObjects = collection.find(query);         $in操作符还是用来限定文档的一个属性，而通过$or可以连接对于多个属性的限定。 $OR         在关系数据库中，可以通过or来限定查询条件，MongoDB也提供了类似的解决方案，也就是使用$or操作符。 > db.foo.find({\"$or\": [{\"name\": \"test\"}, {\"age\": 21}]}) { \"_id\" : ObjectId(\"5d9ab1e940eabd2b62ced66f\"), \"name\" : \"test\", \"age\" : 20 } { \"_id\" : ObjectId(\"5dda6f29f75cb1b4beb2d95f\"), \"name\" : \"x\", \"age\" : 21 }         上述查询语句会查询集合foo中，name属性为test，age属性为21的文档。 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.OrFindTest         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBObject query = new BasicDBObject(); DBObject nameQuery = new BasicDBObject(); nameQuery.put(\"name\", \"test\"); DBObject ageQuery = new BasicDBObject(); ageQuery.put(\"age\", 21); query.put(\"$or\", new DBObject[] {nameQuery, ageQuery}); DBCursor dbObjects = collection.find(query);         $or操作符可以连接多个对于不同（或者相同）属性的查询限定，在一定程度上要比$in灵活。同理也可以用$and操作符来连接多个查询条件。 高级查询         前文介绍了基本的查询功能，能够指定集合中文档的键进行精确或者范围查询，上述基本的查询功能也覆盖了大部分关系数据库中的查询方法。这些基本的查询方法对应的是基础数据类型，由于MongoDB提供了数组和子文档，这就使得查询这些特有的数据类型需要更为强大的查询方法，而这些也是MongoDB优于传统关系数据库查询功能的关键。 数组查询         数组类型是一组相同类型的集合，比如： { \"_id\" : ObjectId(\"5de3abd5c28644d98389fadd\"), \"name\" : \"haha\", \"value\" : [ 1, 2, 3 ] }         其中value属性存储的内容就是数组，数组元素的类型是INT。         如果查询时，查询条件是数组中的一个元素，则一旦文档中的数组元素包含了这个元素，就会返回。 > db.foo.find() { \"_id\" : ObjectId(\"5d9ab1e940eabd2b62ced66f\"), \"name\" : \"test\", \"age\" : 20 } { \"_id\" : ObjectId(\"5dda6f29f75cb1b4beb2d95f\"), \"name\" : \"x\", \"age\" : 21 } { \"_id\" : ObjectId(\"5de3abd5c28644d98389fadd\"), \"name\" : \"haha\", \"value\" : [ 1, 2, 3 ] } { \"_id\" : ObjectId(\"5de3abffc28644d98389fade\"), \"name\" : \"hehe\", \"value\" : [ 3, 4, 5 ] } > db.foo.find({\"value\": 3}) { \"_id\" : ObjectId(\"5de3abd5c28644d98389fadd\"), \"name\" : \"haha\", \"value\" : [ 1, 2, 3 ] } { \"_id\" : ObjectId(\"5de3abffc28644d98389fade\"), \"name\" : \"hehe\", \"value\" : [ 3, 4, 5 ] }         可以看到，db.foo.find({\"value\": 3})可以查询出所有value数组属性包含了3的文档。 精确匹配$all         按照db.foo.find({\"value\": 3})是一种单值的匹配方式，有时我们需要一种使用数组的匹配方式，比如：找出value包含了[1, 2]两个元素的文档，这就需要使用$all操作符了。 > db.foo.find({\"value\": {\"$all\": [1,4]}}) > db.foo.find({\"value\": {\"$all\": [1,2]}}) { \"_id\" : ObjectId(\"5de3abd5c28644d98389fadd\"), \"name\" : \"haha\", \"value\" : [ 1, 2, 3 ] }         可以看到当输入的数组元素是[1, 2]时，就可以查询到对应的文档。 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.ArrayFindTest#all         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBObject query = new BasicDBObject(); DBObject condition = new BasicDBObject(); condition.put(\"$all\", new int[]{1, 2}); query.put(\"value\", condition); DBCursor dbObjects = collection.find(query);         可以看到针对value这个属性，使用的查询限定是{\"$all\": [1, 2]}，表示查询value中全部包含了1和2元素的文档。 长度匹配$size         我们需要查询数组长度为3的文档，可以使用如下方式： > db.foo.find({\"value\": {\"$size\": 3}}) { \"_id\" : ObjectId(\"5de3abd5c28644d98389fadd\"), \"name\" : \"haha\", \"value\" : [ 1, 2, 3 ] } { \"_id\" : ObjectId(\"5de3abffc28644d98389fade\"), \"name\" : \"hehe\", \"value\" : [ 3, 4, 5 ] } > db.foo.find({\"value\": {\"$size\": 2}}) > 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.ArrayFindTest#all         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBObject query = new BasicDBObject(); DBObject condition = new BasicDBObject(); condition.put(\"$size\", 3); query.put(\"value\", condition); DBCursor dbObjects = collection.find(query);         可以看到针对value这个属性，使用的查询限定是{\"$size\": 3}，表示查询value数组的长度为3的文档。 子文档查询         子文档是在文档的一个属性中存储另一个文档，好比自定义数据结构中包括了另外的自定义数据结构。子文档的模式如下所示，其中map属性存储的内容就是一个文档，也就是当前文档的子文档。 { \"_id\" : ObjectId(\"5deccfaf65cd643b1a7f1b0f\"), \"name\" : \"m\", \"age\" : 20, \"map\" : { \"math\" : 90, \"physics\" : 91, \"english\" : 92 } }         子文档的查询分为两种方式，一种是当做属性来看，也就是全匹配，另外一种是根据子文档的部分属性进行匹配查询。         先看一下全匹配，也就是在查询的时候，限定的内容是对子文档的完整描述。 > db.foo.find({\"map\": {\"math\": 90, \"physics\": 91, \"english\": 92}}) { \"_id\" : ObjectId(\"5deccfaf65cd643b1a7f1b0f\"), \"name\" : \"m\", \"age\" : 20, \"map\" : { \"math\" : 90, \"physics\" : 91, \"english\" : 92 } }         这种查询方式没有什么意义，因为给出子文档的全部内容，成本太高了，所以根据子文档的部分属性进行查询是一种常用的方式。而描述子文档的部分内容（属性）就需要利用.操作符，比如：要查询math为90的文档，可以这样描述map.math=90。 > db.foo.find({\"map.math\": 90}) { \"_id\" : ObjectId(\"5deccfaf65cd643b1a7f1b0f\"), \"name\" : \"m\", \"age\" : 20, \"map\" : { \"math\" : 90, \"physics\" : 91, \"english\" : 92 } }         还可以这样查询，查询math属性高于80的全部文档。 > db.foo.find({\"map.math\": {\"$gte\": 80}}) { \"_id\" : ObjectId(\"5deccfaf65cd643b1a7f1b0f\"), \"name\" : \"m\", \"age\" : 20, \"map\" : { \"math\" : 90, \"physics\" : 91, \"english\" : 92 } } { \"_id\" : ObjectId(\"5decd04865cd643b1a7f1b10\"), \"name\" : \"n\", \"age\" : 19, \"map\" : { \"math\" : 80, \"physics\" : 81, \"english\" : 82 } } 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.InnerFindTest#inner_doc_property         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBObject query = new BasicDBObject(); DBObject condition = new BasicDBObject(); condition.put(\"$gte\", 80); query.put(\"map.math\", condition); DBCursor dbObjects = collection.find(query);         可以看到针对map.math这个属性，也就是子文档map中的math属性，使用的查询限定是{\"$gte\": 80}，表示查询map.math中大于等于80的文档。         在看到数组和子文档后，如果数据结构再复杂一些，也就是数组中的元素不再是基本类型，而是文档类型，那么如何进行查询呢？类似如下文档： { \"_id\" : ObjectId(\"5dece6af65cd643b1a7f1b11\"), \"name\" : \"x\", \"age\" : 27, \"maps\" : [ { \"math\" : 90, \"physics\" : 91, \"english\" : 92 }, { \"math\" : 80, \"physics\" : 81, \"english\" : 82 } ] }         对于这种复杂的文档进行查询时，首先可以看到maps是一个数组，对于数组查询可以使用完全给出数组中的元素或者一些特定的操作符，比如： > db.foo.find({\"maps\": {\"$size\": 2}}) { \"_id\" : ObjectId(\"5dece6af65cd643b1a7f1b11\"), \"name\" : \"x\", \"age\" : 27, \"maps\" : [ { \"math\" : 90, \"physics\" : 91, \"english\" : 92 }, { \"math\" : 80, \"physics\" : 81, \"english\" : 82 } ] }         可以通过$size操作符，来查询maps属性（数组）包含了2个元素的文档，又或者给出数组元素中的完整内容进行查询。 > db.foo.find({\"maps\": {\"$all\": [{ \"math\" : 90, \"physics\" : 91, \"english\" : 92 }]}}) { \"_id\" : ObjectId(\"5dece6af65cd643b1a7f1b11\"), \"name\" : \"x\", \"age\" : 27, \"maps\" : [ { \"math\" : 90, \"physics\" : 91, \"english\" : 92 }, { \"math\" : 80, \"physics\" : 81, \"english\" : 82 } ] }         如果是完全给出匹配内容的查询方式，意义不大，我们需要的是给出部分属性的查询，如果要查询english大于80的数据，按照如下方式： > db.foo.find({\"maps\": {\"$all\": [{ \"english\" : {\"$gt\": 80} }]}}) >         可以发现，并不会生效，原因就是在数组查询中，需要给出数组元素的全部内容。这种查询也无法使用maps.english来进行匹配，因为用这个key无法确定性的指定到子文档中的属性，因此需要使用$elemMatch来进行部分指定匹配数组中单个子文档的限定条件，仅当数组中是有多个键的子文档时，可以使用。 > db.foo.find({\"maps\": {\"$elemMatch\": {\"math\": {\"$gte\": 90}}}}) { \"_id\" : ObjectId(\"5dece6af65cd643b1a7f1b11\"), \"name\" : \"x\", \"age\" : 27, \"maps\" : [ { \"math\" : 90, \"physics\" : 91, \"english\" : 92 }, { \"math\" : 80, \"physics\" : 81, \"english\" : 82 } ] }         上述查询指定了maps数组属性中，所有的子文档中math属性大于等于90。 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.InnerFindTest#inner_doc_elem_match         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBObject query = new BasicDBObject(); DBObject condition = new BasicDBObject(); condition.put(\"$gte\", 90); query.put(\"math\", condition); DBObject elementMath = new BasicDBObject(); elementMath.put(\"$elemMatch\", query); DBObject arrayQuery = new BasicDBObject(); arrayQuery.put(\"maps\", elementMath); DBCursor dbObjects = collection.find(arrayQuery);         可以看到，查询的构筑过程已经非常复杂，首先是对于子文档的限定{\"math\": {\"$gte\", 90}}，随后将限定放置在$elemMatch的限定中，最后用elemMatch限定去匹配maps这子文档数组属性。 查询过程应该从最里层开始思考，逐步外推到父文档的属性。 游标         在使用find命令进行查询时，MongoDB并不会将结果直接返回给客户端，而是返回了一个游标，你可以认为是一个指针，指向远端的数据。可以通过遍历的方式获取数据，或者执行一些诸如：排序的操作。 DBObject query = new BasicDBObject(); query.put(\"age\", 20); DBObject project = new BasicDBObject(); project.put(\"name\", 1); project.put(\"_id\", 0); DBCursor dbObjects = collection.find(query, project); dbObjects.forEach(System.out::println);         上述代码查询集合后，返回的就是游标，而这个DBCursor的定义如下： @NotThreadSafe public class DBCursor implements Cursor, Iterable { }         可以看到其实现了Iterable接口，能够支持for循环遍历，而对于真实数据的获取是在需要真正获取结果时才会去请求远端的文档数据。当客户端使用Iterator#next()方法获取数据时，客户端会批量的获取一部分数据或者4MB以内的数据（二者取其小者），这样客户端在调用next()方法时，就不会总去服务端上请求数据了。 这种获取方式优化了客户端获取数据时的时延，并且降低了网络开销对于查询带来的影响         游标不仅仅是客户端的概念，在服务端也有会有游标。当客户端开始对服务端发起查询请求时，服务端也会生成对应的游标，这样客户端和服务端就能够对齐，这好比是一个会话，因此游标不是线程安全的。当然，在服务端的游标也会占用一定资源，当客户端完成遍历或者操作后，就会发起销毁请求给服务端，服务端会销毁对应的游标（会话）。 limit         在查询返回的数据上，限定返回的结果数量。比如：下面的查询，返回数据的结果被限定为2个。 > db.foo.find().limit(2) { \"_id\" : ObjectId(\"5d9ab1e940eabd2b62ced66f\"), \"name\" : \"test\", \"age\" : 20 } { \"_id\" : ObjectId(\"5dda6f29f75cb1b4beb2d95f\"), \"name\" : \"x\", \"age\" : 21 } 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.CursorTest#limit         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBCollection collection = mongoTemplate.getCollection(\"foo\"); DBCursor dbObjects = collection.find().limit(2); dbObjects.forEach(System.out::println); skip         在查询返回的数据上，过滤掉前几个匹配的文档。比如：下面的查询，返回数据的结果会过滤掉前2个。 > db.foo.find().skip(2) { \"_id\" : ObjectId(\"5de3abd5c28644d98389fadd\"), \"name\" : \"haha\", \"value\" : [ 1, 2, 3 ] } { \"_id\" : ObjectId(\"5de3abffc28644d98389fade\"), \"name\" : \"hehe\", \"value\" : [ 3, 4, 5 ] } { \"_id\" : ObjectId(\"5deccfaf65cd643b1a7f1b0f\"), \"name\" : \"m\", \"age\" : 20, \"map\" : { \"math\" : 90, \"physics\" : 91, \"english\" : 92 } } { \"_id\" : ObjectId(\"5decd04865cd643b1a7f1b10\"), \"name\" : \"n\", \"age\" : 19, \"map\" : { \"math\" : 80, \"physics\" : 81, \"english\" : 82 } } { \"_id\" : ObjectId(\"5dece6af65cd643b1a7f1b11\"), \"name\" : \"x\", \"age\" : 27, \"maps\" : [ { \"math\" : 90, \"physics\" : 91, \"english\" : 92 }, { \"math\" : 80, \"physics\" : 81, \"english\" : 82 } ] } > 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.CursorTest#skip         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBCollection collection = mongoTemplate.getCollection(\"foo\"); DBCursor dbObjects = collection.find().skip(2); dbObjects.forEach(System.out::println); 使用skip过滤少量数据是可以的，但是如果用来过滤大量数据（比如：上万），就会出现性能瓶颈，因为它都是要查询出符合约束的数据，然后再加以过滤，这样的开销会随着过滤数据量级的提升而变得越来越差。         过滤大量的数据，可以在功能侧考虑一些支持，比如：增加一个查询条件，时间；又或者将上一次查询的结果的id作为下一次查询的条件传入。 sort         在查询返回的数据上，可以通过sort来对集合的文档进行排序，其中1表示升序，-1表示降序。 > db.foo.find().sort({\"name\":1}).limit(3) { \"_id\" : ObjectId(\"5de3abd5c28644d98389fadd\"), \"name\" : \"haha\", \"value\" : [ 1, 2, 3 ] } { \"_id\" : ObjectId(\"5de3abffc28644d98389fade\"), \"name\" : \"hehe\", \"value\" : [ 3, 4, 5 ] } { \"_id\" : ObjectId(\"5deccfaf65cd643b1a7f1b0f\"), \"name\" : \"m\", \"age\" : 20, \"map\" : { \"math\" : 90, \"physics\" : 91, \"english\" : 92 } } 对于java端的操作可以参考：com.murdock.books.mongodbguide.chapter4.CursorTest#sort         使用MongoDB的Java客户端，进行查询文档的关键逻辑如下： DBCollection collection = mongoTemplate.getCollection(\"foo\"); DBObject dbObject = new BasicDBObject(); dbObject.put(\"name\", 1); DBCursor dbObjects = collection.find().limit(3).sort(dbObject); dbObjects.forEach(System.out::println); By mongodb-guide，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2022-06-17 02:07:42 "},"book/mongodb-guide-chapter5.html":{"url":"book/mongodb-guide-chapter5.html","title":"MongoDB-第五章-索引","keywords":"","body":"索引         索引如同字典的目录一样，是用来加速查询的。具有正确索引的查询会比没有索引的查询快几个数量级，当随着数据量级变大时，愈发明显。 索引简介         首先我们准备一个集合author_test_collection，集合中的文档主要包括了，以下几个字段：name和age，其中name的类型是字符串，而age是整型。 记住，任何文档都会包含一个_id字段         集合中包含了100万个元素。 > db.author_test_collection.count(); 1000000         查找name为Author-3000的文档，通过explain命令，可以输出执行计划。 > db.author_test_collection.find({\"name\":\"Author-3000\"}).explain(\"executionStats\") { \"queryPlanner\" : { \"plannerVersion\" : 1, \"namespace\" : \"test.author_test_collection\", \"indexFilterSet\" : false, \"parsedQuery\" : { \"name\" : { \"$eq\" : \"Author-3000\" } }, \"winningPlan\" : { \"stage\" : \"COLLSCAN\", \"filter\" : { \"name\" : { \"$eq\" : \"Author-3000\" } }, \"direction\" : \"forward\" }, \"rejectedPlans\" : [ ] }, \"executionStats\" : { \"executionSuccess\" : true, \"nReturned\" : 1, \"executionTimeMillis\" : 652, \"totalKeysExamined\" : 0, \"totalDocsExamined\" : 1000000, \"executionStages\" : { \"stage\" : \"COLLSCAN\", \"filter\" : { \"name\" : { \"$eq\" : \"Author-3000\" } }, \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 570, \"works\" : 1000002, \"advanced\" : 1, \"needTime\" : 1000000, \"needYield\" : 0, \"saveState\" : 7812, \"restoreState\" : 7812, \"isEOF\" : 1, \"invalidates\" : 0, \"direction\" : \"forward\", \"docsExamined\" : 1000000 } }, \"serverInfo\" : { \"host\" : \"c40e51fb2caa\", \"port\" : 27017, \"version\" : \"3.6.9\", \"gitVersion\" : \"167861a164723168adfaaa866f310cb94010428f\" }, \"ok\" : 1 }         我们先不用关注执行计划中输出的内容细节，看几个主要的数据指标。 问题 分析 查询走全表扫描 stage的描述是COLLSCAN，这个表示全表扫描 执行耗时比较长 executionTimeMillis执行耗时在652毫秒，这个已经很长了 工作开销很大 works是MongoDB将操作分解为更细力度的操作单元，这里要耗费1000002个         通过使用ensureIndex可以创建集合的索引，这里根据name属性创建对应的索引： > db.author_test_collection.ensureIndex({\"name\": 1}) { \"createdCollectionAutomatically\" : false, \"numIndexesBefore\" : 1, \"numIndexesAfter\" : 2, \"ok\" : 1 }         ensureIndex会在指定的key上建立索引，同时第二个参数表示该索引的方向，其中1表示升序，而-1表示降序。对于大多数查询场景来说，区别不大，因为对于索引的执行总是从中间开始，但是升序会保证最开始的数据会在内存中，这是一个细微的差别。 MongoDB的索引和MySQL索引类似，都是左匹配。         使用getIndexes命令，可以查看当前集合上的索引情况。 > db.author_test_collection.getIndexes() [ { \"v\" : 2, \"key\" : { \"_id\" : 1 }, \"name\" : \"_id_\", \"ns\" : \"test.author_test_collection\" }, { \"v\" : 2, \"key\" : { \"name\" : 1 }, \"name\" : \"name_1\", \"ns\" : \"test.author_test_collection\" } ]         可以看到，集合author_test_collection上有两个索引，其中name_1是新添加的。新增索引后，再次执行先前的执行计划，看一下效果。 > db.author_test_collection.find({\"name\":\"Author-3000\"}).explain(\"executionStats\") { \"queryPlanner\" : { \"plannerVersion\" : 1, \"namespace\" : \"test.author_test_collection\", \"indexFilterSet\" : false, \"parsedQuery\" : { \"name\" : { \"$eq\" : \"Author-3000\" } }, \"winningPlan\" : { \"stage\" : \"FETCH\", \"inputStage\" : { \"stage\" : \"IXSCAN\", \"keyPattern\" : { \"name\" : 1 }, \"indexName\" : \"name_1\", \"isMultiKey\" : false, \"multiKeyPaths\" : { \"name\" : [ ] }, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 2, \"direction\" : \"forward\", \"indexBounds\" : { \"name\" : [ \"[\\\"Author-3000\\\", \\\"Author-3000\\\"]\" ] } } }, \"rejectedPlans\" : [ ] }, \"executionStats\" : { \"executionSuccess\" : true, \"nReturned\" : 1, \"executionTimeMillis\" : 1, \"totalKeysExamined\" : 1, \"totalDocsExamined\" : 1, \"executionStages\" : { \"stage\" : \"FETCH\", \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 0, \"works\" : 2, \"advanced\" : 1, \"needTime\" : 0, \"needYield\" : 0, \"saveState\" : 0, \"restoreState\" : 0, \"isEOF\" : 1, \"invalidates\" : 0, \"docsExamined\" : 1, \"alreadyHasObj\" : 0, \"inputStage\" : { \"stage\" : \"IXSCAN\", \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 0, \"works\" : 2, \"advanced\" : 1, \"needTime\" : 0, \"needYield\" : 0, \"saveState\" : 0, \"restoreState\" : 0, \"isEOF\" : 1, \"invalidates\" : 0, \"keyPattern\" : { \"name\" : 1 }, \"indexName\" : \"name_1\", \"isMultiKey\" : false, \"multiKeyPaths\" : { \"name\" : [ ] }, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 2, \"direction\" : \"forward\", \"indexBounds\" : { \"name\" : [ \"[\\\"Author-3000\\\", \\\"Author-3000\\\"]\" ] }, \"keysExamined\" : 1, \"seeks\" : 1, \"dupsTested\" : 0, \"dupsDropped\" : 0, \"seenInvalidated\" : 0 } } }, \"serverInfo\" : { \"host\" : \"c40e51fb2caa\", \"port\" : 27017, \"version\" : \"3.6.9\", \"gitVersion\" : \"167861a164723168adfaaa866f310cb94010428f\" }, \"ok\" : 1 }         可以看到stage已经从 COLLSCAN 变为了 IXSCAN，也就是说从全表扫描变为了按照索引扫描。有了索引，就好比查字典时有了字母的顺序，使得不用翻遍整个字典才能找到需要的内容，工作量也会减少。可以看到work只有4(2 + 2)，从1000002下降到4，是非常显著的，相差了百万个量级。         但是并不是我们将需要查询的字段都放到索引中就可以，有时我们的查询需要考虑顺序，比如： db.author_test_collection.find({\"name\":\"Author-2000\"}).sort({\"age\":1})         该查询用来查询名称为Author-2000的所有作者，同时按照age正序（小到大）排序返回。可以输出以下执行计划（重点部分）。 \"executionStages\" : { \"stage\" : \"SORT\", \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 0, \"works\" : 5, \"advanced\" : 1, \"needTime\" : 3, \"needYield\" : 0, \"saveState\" : 0, \"restoreState\" : 0, \"isEOF\" : 1, \"invalidates\" : 0, \"sortPattern\" : { \"age\" : 1 }, \"memUsage\" : 118, \"memLimit\" : 33554432, \"inputStage\" : { \"stage\" : \"SORT_KEY_GENERATOR\", \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 0, \"works\" : 3, \"advanced\" : 1, \"needTime\" : 1, \"needYield\" : 0, \"saveState\" : 0, \"restoreState\" : 0, \"isEOF\" : 1, \"invalidates\" : 0, \"inputStage\" : { \"stage\" : \"FETCH\", \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 0, \"works\" : 2, \"advanced\" : 1, \"needTime\" : 0, \"needYield\" : 0, \"saveState\" : 0, \"restoreState\" : 0, \"isEOF\" : 1, \"invalidates\" : 0, \"docsExamined\" : 1, \"alreadyHasObj\" : 0, \"inputStage\" : { \"stage\" : \"IXSCAN\", \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 0, \"works\" : 2, \"advanced\" : 1, \"needTime\" : 0, \"needYield\" : 0, \"saveState\" : 0, \"restoreState\" : 0, \"isEOF\" : 1, \"invalidates\" : 0, \"keyPattern\" : { \"name\" : 1 }, \"indexName\" : \"name_1\", \"isMultiKey\" : false, \"multiKeyPaths\" : { \"name\" : [ ] }, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 2, \"direction\" : \"forward\", \"indexBounds\" : { \"name\" : [ \"[\\\"Author-2000\\\", \\\"Author-2000\\\"]\" ] }, \"keysExamined\" : 1, \"seeks\" : 1, \"dupsTested\" : 0, \"dupsDropped\" : 0, \"seenInvalidated\" : 0 } } } }, \"allPlansExecution\" : [ ]         可以看到首先查询的数据会消耗2个work通过IXSCAN索引扫描命中数据，然后经过FETCH阶段，消耗2个work将数据取出，取出的数据需要经历SORT_KEY_GENERATOR消耗1个work进行排序器的生成（虽然只有一个数据），最终通过SORT阶段消耗5个work将数据完成排序后返回。 总计开销是10个work         对于数据的查询输入，有name和age两个参数，在age上有排序，下面在name和age上建立索引。 db.author_test_collection.ensureIndex({\"name\":1, \"age\":1})         然后再次执行，可以看到执行计划有所变化。 \"executionStages\" : { \"stage\" : \"FETCH\", \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 0, \"works\" : 3, \"advanced\" : 1, \"needTime\" : 0, \"needYield\" : 0, \"saveState\" : 0, \"restoreState\" : 0, \"isEOF\" : 1, \"invalidates\" : 0, \"docsExamined\" : 1, \"alreadyHasObj\" : 0, \"inputStage\" : { \"stage\" : \"IXSCAN\", \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 0, \"works\" : 2, \"advanced\" : 1, \"needTime\" : 0, \"needYield\" : 0, \"saveState\" : 0, \"restoreState\" : 0, \"isEOF\" : 1, \"invalidates\" : 0, \"keyPattern\" : { \"name\" : 1, \"age\" : 1 }, \"indexName\" : \"name_1_age_1\", \"isMultiKey\" : false, \"multiKeyPaths\" : { \"name\" : [ ], \"age\" : [ ] }, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 2, \"direction\" : \"forward\", \"indexBounds\" : { \"name\" : [ \"[\\\"Author-2000\\\", \\\"Author-2000\\\"]\" ], \"age\" : [ \"[MinKey, MaxKey]\" ] }, \"keysExamined\" : 1, \"seeks\" : 1, \"dupsTested\" : 0, \"dupsDropped\" : 0, \"seenInvalidated\" : 0 } }         可以看到首先消耗2个work根据name_1_age_1的索引就可以拿到一个指定name且age排好序的结果，然后将其通过FETCH阶段，消耗3个work将数据返回即可。整个消耗work只有原来的一半。         在建立索引时，不仅要考虑输入的场景字段，还要考虑会在哪些字段上排序。 每个集合上的索引默认最大个数是64个，一般来说是够用了。 唯一索引         通过建立索引，可以让查询变得更加有效率，这里提到的索引和MySQL中的索引是一个含义。在关系数据库中，还有一种索引称之为唯一索引（Unique），它指的是这个索引能够唯一的确定一条记录，并且能够用这个约束来约束集合中的所有数据。         在MongoDB中，每个集合天生就有一个唯一索引，_id，它表示一行数据的id。使用者也可以创建自己的唯一索引，例如： db.author_test_collection.ensureIndex({\"name\":1, \"age\":1}, {\"unique\":true})         通过创建索引时，增加{\"unique\":true}，可以将该索引设置为唯一索引。 执行计划与Hint         以如下执行计划为例，进行执行计划的内容分析。 { \"queryPlanner\" : { \"plannerVersion\" : 1, \"namespace\" : \"test.author_test_collection\", \"indexFilterSet\" : false, \"parsedQuery\" : { \"name\" : { \"$eq\" : \"Author-2000\" } }, \"winningPlan\" : { \"stage\" : \"FETCH\", \"inputStage\" : { \"stage\" : \"IXSCAN\", \"keyPattern\" : { \"name\" : 1, \"age\" : 1 }, \"indexName\" : \"name_1_age_1\", \"isMultiKey\" : false, \"multiKeyPaths\" : { \"name\" : [ ], \"age\" : [ ] }, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 2, \"direction\" : \"forward\", \"indexBounds\" : { \"name\" : [ \"[\\\"Author-2000\\\", \\\"Author-2000\\\"]\" ], \"age\" : [ \"[MinKey, MaxKey]\" ] } } }, \"rejectedPlans\" : [ ] }, \"executionStats\" : { \"executionSuccess\" : true, \"nReturned\" : 1, \"executionTimeMillis\" : 1, \"totalKeysExamined\" : 1, \"totalDocsExamined\" : 1, \"executionStages\" : { \"stage\" : \"FETCH\", \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 0, \"works\" : 3, \"advanced\" : 1, \"needTime\" : 0, \"needYield\" : 0, \"saveState\" : 0, \"restoreState\" : 0, \"isEOF\" : 1, \"invalidates\" : 0, \"docsExamined\" : 1, \"alreadyHasObj\" : 0, \"inputStage\" : { \"stage\" : \"IXSCAN\", \"nReturned\" : 1, \"executionTimeMillisEstimate\" : 0, \"works\" : 2, \"advanced\" : 1, \"needTime\" : 0, \"needYield\" : 0, \"saveState\" : 0, \"restoreState\" : 0, \"isEOF\" : 1, \"invalidates\" : 0, \"keyPattern\" : { \"name\" : 1, \"age\" : 1 }, \"indexName\" : \"name_1_age_1\", \"isMultiKey\" : false, \"multiKeyPaths\" : { \"name\" : [ ], \"age\" : [ ] }, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 2, \"direction\" : \"forward\", \"indexBounds\" : { \"name\" : [ \"[\\\"Author-2000\\\", \\\"Author-2000\\\"]\" ], \"age\" : [ \"[MinKey, MaxKey]\" ] }, \"keysExamined\" : 1, \"seeks\" : 1, \"dupsTested\" : 0, \"dupsDropped\" : 0, \"seenInvalidated\" : 0 } }, \"allPlansExecution\" : [ ] } \"ok\" : 1 }         在执行计划queryPlanner中会包含本地选取的执行计划，和被拒绝的执行计划。在executionStats中会有详细的执行计划过程说明，从整体上会有以下内容需要注意： 项目 含义 executionStats.executionSuccess 是否执行成功 executionStats.nReturned 查询的返回条数 executionStats.executionTimeMillis 整体执行时间 executionStats.totalKeysExamined 索引扫描次数 executionStats.totalDocsExamined 文档扫描次数         在executionStages中有当前查询的不同阶段明细，也就是由这些Stage组成的本次查询，Stage好比阶段，一次查询由多个阶段来完成，阶段主要分为以下内容，它们负责不同的工作。 阶段名称 含义 COLLSCAN 全表扫描 IXSCAN 索引扫描 FETCH 根据索引去检索指定文档，有点回表的感觉 SORT 表明在内存中进行了排序，在开始未加age索引时有该阶段 LIMIT 使用limit限制返回数 SKIP 使用skip进行跳过 IDHACK 针对_id进行查询 COUNT count()之类进行count运算 PROJECTION 限定返回字段时候stage的返回 SHARDING_FILTER 通过mongos对分片数据进行查询 SHARD_MERGE 将各个分片返回数据进行merge 索引管理         单个索引的名称长度一般不能超过121个字节，也就是60个字符，这个很容易做到。在之前建立索引时，只罗列了字段名，所以默认的索引名称都是字段+索引方向构成，可以在创建索引的时候，给一个好理解的名称。 db.author_test_collection.ensureIndex({\"name\":1, \"age\":1}, {\"name\":\"index_name\"})         在创建索引时，可以在第二个参数传递索引的名字。         索引的建立需要消耗不少资源，当索引建立时，mongodb对于请求不能够立即响应，因此建立索引的时间需要放在访问量较低的时候，同时也不能够停机进行索引建立。可以通过增加{\"background\": true}参数，例如： db.author_test_collection.ensureIndex({\"name\":1, \"age\":1}, {\"name\":\"index_name\"}, {\"background\": true})         这时，索引建立会在后台慢慢完成，MongoDB能够处理请求的同时完成索引在后台建立，虽然慢了些，但是不会阻塞请求。 地理空间索引         MongoDB支持空间索引，因此可以方便的完成基于地理坐标的查询和搜索。我们定义一个Poi对象： public class Poi implements Serializable { private static final long serialVersionUID = -6595624172489524435L; /** * ID */ private Long num; /** * 名称 */ private String name; /** * 城市 */ private String cityName; /** * 地区 */ private String areaName; /** * 街道 */ private String streetName; /** * 位置 */ private Double[] location; /** * 类目名 */ private String categoryName; /** * 属性名 */ private String propertyName; /** * 联系方式 */ private String[] contactNumbers; }         该对象声明了地理位置的名称，市、区和街道地址，以及地理位置（经纬度），通过使用以下测试将数据完成初始化。 @Test public void init() throws Exception { Path path = Paths.get(\"src/test/resources\", \"hangzhou-2018-poi.csv\"); List allLines = Files.readAllLines(path); allLines.parallelStream() .map(s -> { String[] split = s.split(\",\"); if (split.length == 8) { try { Long num = Long.parseLong(split[0].trim()); String name = split[1].trim(); String streetName = split[2].trim(); Double longitude = Double.parseDouble(split[3].trim()); Double latitude = Double.parseDouble(split[4].trim()); String[] address = split[5].split(\";\"); String cityName = null; String areaName = null; if (address.length == 2) { cityName = address[0].trim(); areaName = address[1].trim(); } else { cityName = address[0].trim(); } String[] cate = split[6].split(\";\"); String categoryName = cate[0].trim(); String propertyName = cate[1].trim(); String[] contacts = split[7].split(\";\"); Poi poi = new Poi(); poi.setNum(num); poi.setName(name); poi.setLocation(new Double[]{longitude, latitude}); poi.setCityName(cityName); poi.setAreaName(areaName); poi.setStreetName(streetName); poi.setCategoryName(categoryName); poi.setPropertyName(propertyName); poi.setContactNumbers(contacts); return poi; } catch (Exception ex) { System.err.println(s); return null; } } else { return null; } }) .filter(Objects::nonNull) .forEach(poi -> mongoTemplate.save(poi, \"poi\")); } 上述测试文件和类型定义，可以在项目工程mongodb-guide-chapter5中找到。当前数据大约有11万左右的POI信息。         在开始检索之前，需要建立地理位置索引，这里可以用如下命令进行建立： db.poi.createIndex({\"location\":\"2d\"})         建立完成后，使用MongoTemplate来查询一下，离笔者家最近的（2公里）的火锅店。 Query query = new Query(); Criteria category = Criteria.where(\"categoryName\").is(\"美食\"); Criteria property = Criteria.where(\"propertyName\").is(\"火锅\"); query.addCriteria(category).addCriteria(property); NearQuery nearQuery = NearQuery.near(30.2542303641, 120.029316088) .maxDistance(2/111.0d) .distanceMultiplier(111) .query(query); GeoResults poi = mongoTemplate.geoNear(nearQuery, Poi.class, \"poi\"); System.out.println(poi); poi.forEach(System.out::println);         可以看到对应的输出： GeoResults: [averageDistance: 1.0906241539249202 org.springframework.data.geo.CustomMetric@10650953, results: GeoResult [content: Poi{num=18631, name='锅sir时尚火锅(西溪店)', cityName='杭州市', areaName='余杭区', streetName='五常街道丰岭路150号', location=[30.2518344901, 120.027799463], categoryName='美食', propertyName='火锅', contactNumbers=[15088631350]}, distance: 0.31474643777909406 org.springframework.data.geo.CustomMetric@10650953, ],GeoResult [content: Poi{num=929494, name='华记肉蟹煲', cityName='杭州市', areaName='余杭区', streetName='五常大道156号', location=[30.2478319766, 120.02888752], categoryName='美食', propertyName='火锅', contactNumbers=[13858025848]}, distance: 0.7118123988834714 org.springframework.data.geo.CustomMetric@10650953, ],GeoResult [content: Poi{num=138637, name='贵州闵孔维火锅', cityName='杭州市', areaName='余杭区', streetName='乐玛摄影乐品美学馆南(联胜路东)', location=[30.2481295413, 120.025993642], categoryName='美食', propertyName='火锅', contactNumbers=[15158096376]}, distance: 0.771100041115541 org.springframework.data.geo.CustomMetric@10650953, ],GeoResult [content: Poi{num=154459, name='铜顺祥老北京炭火锅(五常店)', cityName='杭州市', areaName='余杭区', streetName='五常大道169-2号楼达峰科技园对面', location=[30.2464425735, 120.028698033], categoryName='美食', propertyName='火锅', contactNumbers=[13396553333]}, distance: 0.8671627646732913 org.springframework.data.geo.CustomMetric@10650953, ],GeoResult [content: Poi{num=29323, name='重庆老基地主题火锅(杭州总店)', cityName='杭州市', areaName='余杭区', streetName='留下五常街道天目山西路15号宏丰生活广场北面C2-103号', location=[30.240354346, 120.028189614], categoryName='美食', propertyName='火锅', contactNumbers=[0571-88667515]}, distance: 1.5453050765681462 org.springframework.data.geo.CustomMetric@10650953, ],GeoResult [content: Poi{num=300403, name='锅内锅外(西溪印象城店)', cityName='杭州市', areaName='西湖区', streetName='五常大道1号杭州西溪印象城L401', location=[30.249636746, 120.043730212], categoryName='美食', propertyName='火锅', contactNumbers=[0571-85100078]}, distance: 1.6792517080143305 org.springframework.data.geo.CustomMetric@10650953, ],GeoResult [content: Poi{num=313858, name='煮火火锅', cityName='杭州市', areaName='西湖区', streetName='五常大道1号(近西溪湿地公园)西溪印象城L2层L248', location=[30.2495355104, 120.044319313], categoryName='美食', propertyName='火锅', contactNumbers=[0571-88639773]}, distance: 1.7449906504405666 org.springframework.data.geo.CustomMetric@10650953, ]] GeoResult [content: Poi{num=18631, name='锅sir时尚火锅(西溪店)', cityName='杭州市', areaName='余杭区', streetName='五常街道丰岭路150号', location=[30.2518344901, 120.027799463], categoryName='美食', propertyName='火锅', contactNumbers=[15088631350]}, distance: 0.31474643777909406 org.springframework.data.geo.CustomMetric@10650953, ] GeoResult [content: Poi{num=929494, name='华记肉蟹煲', cityName='杭州市', areaName='余杭区', streetName='五常大道156号', location=[30.2478319766, 120.02888752], categoryName='美食', propertyName='火锅', contactNumbers=[13858025848]}, distance: 0.7118123988834714 org.springframework.data.geo.CustomMetric@10650953, ] GeoResult [content: Poi{num=138637, name='贵州闵孔维火锅', cityName='杭州市', areaName='余杭区', streetName='乐玛摄影乐品美学馆南(联胜路东)', location=[30.2481295413, 120.025993642], categoryName='美食', propertyName='火锅', contactNumbers=[15158096376]}, distance: 0.771100041115541 org.springframework.data.geo.CustomMetric@10650953, ] GeoResult [content: Poi{num=154459, name='铜顺祥老北京炭火锅(五常店)', cityName='杭州市', areaName='余杭区', streetName='五常大道169-2号楼达峰科技园对面', location=[30.2464425735, 120.028698033], categoryName='美食', propertyName='火锅', contactNumbers=[13396553333]}, distance: 0.8671627646732913 org.springframework.data.geo.CustomMetric@10650953, ] GeoResult [content: Poi{num=29323, name='重庆老基地主题火锅(杭州总店)', cityName='杭州市', areaName='余杭区', streetName='留下五常街道天目山西路15号宏丰生活广场北面C2-103号', location=[30.240354346, 120.028189614], categoryName='美食', propertyName='火锅', contactNumbers=[0571-88667515]}, distance: 1.5453050765681462 org.springframework.data.geo.CustomMetric@10650953, ] GeoResult [content: Poi{num=300403, name='锅内锅外(西溪印象城店)', cityName='杭州市', areaName='西湖区', streetName='五常大道1号杭州西溪印象城L401', location=[30.249636746, 120.043730212], categoryName='美食', propertyName='火锅', contactNumbers=[0571-85100078]}, distance: 1.6792517080143305 org.springframework.data.geo.CustomMetric@10650953, ] GeoResult [content: Poi{num=313858, name='煮火火锅', cityName='杭州市', areaName='西湖区', streetName='五常大道1号(近西溪湿地公园)西溪印象城L2层L248', location=[30.2495355104, 120.044319313], categoryName='美食', propertyName='火锅', contactNumbers=[0571-88639773]}, distance: 1.7449906504405666 org.springframework.data.geo.CustomMetric@10650953, ]         返回的结果包含了符合要求的Poi信息，给出了平均的距离，想尝试的同学可以试着写一个找寻自家最近加油站的程序。 By mongodb-guide，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2022-06-17 02:07:42 "}}